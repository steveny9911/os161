- need to fix
    - vm_fault:
        - a full TLB leads to a kernel panic
        - read-only text segment (three address space - text, data, stack are - are all read-write-able now)
            - current TLB entries are loaded with TLBLO_DIRTY (set as ON)
                - pages are therefore read and write-able
            - text segment should be read only
                - load TLB entries with TLBLO_DIRTY (set as OFF)
            - BUT! load_elf needs TLBLO_DIRTY as ON
                - so ---> we could add a flag somewhere

- memory managment
    - during bootstrap, kernel calls getppages() -> which calls ram_stealmem()
    - we want to manage our own memory *after* bootstrap
    - in vm_bootstrap() ---> we manage the remaining memory

- TLB management
    - global and pid fields are unused (invalidate TLB ONLY when context switch to another thread)
    - TLB fault: 
        - if there is free space: load new entry into TLB
        - if not ---> TLB eviction:
            - round-robin TLB replacement policy

- write to disk

- page eviction

- synchronization protocol?

- need to implement
    - data structures
        - page table:
            - replace pbase with page table
            - three segments (text, data, stack)
        - free page map?
        - address space:
    - as_define_region
    - as_prepare_load
    - as_copy

    - functions/syscalls
        - sbrk():
        - as_copy(), as_destroy():
        - tlbshootdown(), tlbshootdown_all():

TLB fault steps:
1. trap into kernel (vm_fault(faultaddress))
2. look up corresponding ppage for faultaddress
    - look up translation in page table
        - return error if translation is invalid
        - deal with page fault
            - allocate a ppage for new translation
            - read from disk
3. install translation into TLB
4. resume execution
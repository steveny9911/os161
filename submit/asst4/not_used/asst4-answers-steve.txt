===== 1. What are the ELF magic numbers? =====
/kern/include/elf.h
An array of bytes that specify how to interpret the file; there are 4 bytes --- 3x7f, 'E', 'L', 'F'


===== 2. What is the difference between UIO_USERISPACE and UIO_USERSPACE? When should one use UIO_SYSSPACE instead? =====
/kern/include/uio.h
UIO_USERISPACE --- user process code
UIO_USERSPACE --- user process data
Use UIO_SYSSPACE when writing data to the kernel buffer


===== 3. Why can the struct uio that is used to read in a segment be allocated on the stack in load_segment() (i.e., where does the memory read actually go)? =====
- load_segment() loads a segment from virtual address into memeory
- uio.iovec will be filled with the pointer of iovec --- pointer of the virtual address and the size to be store; so the struct uio can be allocated on the stack
- Data then is read from the file onto the uio, which is on the stack


===== 4. In runprogram(), why is it important to call vfs_close() before going to usermode? =====
We will lose the pointer to the file (vnode) if we do not close the file before going into usermode; possible memory leak so that we might never be able to close the file


===== 5. What function forces the processor to switch into usermode? Is this function machine dependent? =====
In trap.c
mips_usermode() does the actual work for entering user mode
Which is called by enter_new_process() or enter_forked_process()
It is machine-independent


===== 6. In what file are copyin and copyout defined? memmove? Why can't copyin and copyout be implemented as simply as memmove? =====
- copyin() and copyout() are defined in copyinout.h and implemented in copyinout.c
- memmove() is defined in string.h and implemented in memmove.c
- copyin() and copyout() are copying blocks of memory between user and kernel address
  - they make sure user does not get access to anything in the kernel
  - memmove() copies memory without any consideration for user or kenerl space  


===== 7. What (briefly) is the purpose of userptr_t? =====
Merely used to denote it provides pointer address for user space region so that it won't mix with other kind of pointers


===== 8. What is the numerical value of the exception code for a MIPS system call? =====
#define EX_SYS    8

===== 9. How many bytes is an instruction in MIPS? (Answer this by reading syscall() carefully, not by looking somewhere else.) =====
4 bytes --- program counter stored in the trapframe will be incremented by one instruction


===== 10. Why do you "probably want to change" the implementation of kill_curthread()? =====
The kenerl shouldn't panic when user program faults; OS should still be running while user program could exit on error


===== 11. What would be required to implement a system call that took more than 4 arguments? =====
Need to place then get arguments on the user-level stack, starting at sp+16


===== 12. What is the purpose of the SYSCALL macro? =====
SYSCALL macro loads the system call number into register v0 and jumps to the shared code


===== 13. What is the MIPS instruction that actually triggers a system call? (Answer this by reading the source in this directory, not looking somewhere else.) =====
Line 84 of syscalls-mips.S executes an instruction 'syscall'


===== 14. After reading syscalls-mips.S and syscall.c, you should be prepared to answer the following question: OS/161 supports 64-bit values; lseek() takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg2), and needs to return a 64-bit offset value. In void syscall(struct trapframe *tf) where will you find each of the three arguments (in which registers) and how will you return the 64-bit offset? =====
- 32-bit arguments are passed in register a0-a3, while 64-bits arguments are passed with aligned register a0-a1 or a2-a3
- arg0 in a0 (32-bit)
- arg1 in a2-a3 (64-bit)
- arg2 must go on user level stack starting at sp+16
- register a1 is unused
- return in v0-v1 (64-bit)

===== 15. As you were reading the code in runprogram.c and loadelf.c, you probably noticed how the kernel manipulates the files. Which kernel function is called to open a file? Which macro is called to read the file? What about to write a file? Which data structure is used in the kernel to represent an open file? =====
- open a file with --- vfs_open()
- read the file --- VOP_READ macro
- write a file --- VOP_WRITE macro
- data structure represent an open file --- struct vnode


===== 16. What is the purpose of VOP_INCREF and VOP_DECREF? =====
Incrementing and decrementing reference counter of the 'vnode'
- vnode->vn_refcount is set to 0 upon removing
- set to 1 upon init
- reference counter maintains a number of references to the object; once it's 0, we can safely free the object

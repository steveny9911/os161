========== Step 4 ==========
----- 4.1 -----
$ sys161
sys161: System/161 release 2.0.3, compiled Sep  4 2020 11:32:51
sys161: Usage: sys161 [sys161 options] kernel [kernel args...]
sys161:    sys161 options:
sys161:      -c config      Use alternate config file
sys161:      -D count       Set disk I/O doom counter
sys161:      -f file        (trace161 only)
sys161:      -P             (trace161 only)
sys161:      -p port        Listen for gdb over TCP on specified port
sys161:      -s             Pass signal-generating characters through
sys161:      -t[flags]      (trace161 only)
sys161:      -w             Wait for debugger before starting
sys161:      -X             Don't wait for debugger; exit instead
sys161:      -Z seconds     Set watchdog timer to specified time

----- 4.2 -----
$ git log
commit 87625ed72687ddf70e96507e23e1c4ff0a166a1a (HEAD -> master, tag: asst1-start, origin/master)
Author: steveny9911 <stevenywy@gmail.com>
Date:   Sat Sep 12 13:22:03 2020 -0700

ignore defs.mk

commit a593d4b74bd4dc2a2db597e93445c8bcc56b6797
Author: steveny9911 <stevenywy@gmail.com>
Date:   Fri Sep 4 11:52:52 2020 -0700

gitignore

commit 5d9a2fe48ff96bb80c8ec248b06ab30a4bd14847
Author: steveny9911 <stevenywy@gmail.com>
Date:   Fri Sep 4 11:41:15 2020 -0700

Initial commit of os161 for CPEN331

----- 4.3 -----
$ git tag
asst1-start

========== Step 5 ========== (Questions & Responses)
----- Q 5.1 ----- In the book chapters and in class you were introduced to the mechanisms used to transfer control between user processes and the operating system. Tell us where we can find the first line of OS/161 code that is executed when a trap occurs. Then tell us where control gets transferred to from that point. What about an interrupt? How does that differ?
----- R 5.1 ----- 
- When an exception / trap occurs, control is transferred to mips_utlb_handler (line 68) or mips_general_handler (line 86) in the file src/kern/arch/mips/locore/exception-mips1.S depending on whehter is is a UTLB exception or a general exception (though here they all both handled by common_exception (line 104))
- Following common_exception, trapframe will be created for saving registers
- Then, mips_trap will be called with argument of pointer to the trapframe located in src/kern/arch/mips/locore/trap.c
  - Inside mips_trap, depending on the kind of exception, each will be delegated
  - Interrupt is delegated differently through the interrupt dispathcer in src/kern/arch/sys161/dev/lamebus_machdep.c mainbus_interrupt function
  - Syscall will be delegated to syscall function in src/kern/arch/mips/syscall/syscall.c
    - Syscall will be further delegated depending on the call number variable stored in trapframe v0
  - Further delegated for TLB, kernel fault, and other exceptions
- Interrupt here is considered to be the same, as it is simply a spacial case of trap; it is differently delegated inside mips_trap


----- Q 5.2 ----- Making a system call, such as write, ultimately leads to a trap. Find the code in OS/161 that invokes system calls from user programs and causes traps. In which file and on which lines did you find this code?
----- R 5.2 -----
userland program userland/lib/libc/arch/mips/syscalls-mips.S calls syscall on line 84


----- Q 5.3 ----- Why do you suppose there are libc functions in the "common" part of the source tree (common/libc) as well as in userland/lib/libc?
----- R 5.3 -----
- These two locations contain files (and functions) that are the same and different (or additional)
- Both the user program and the kernel also use these basic functions


----- Q 5.4 ----- Name two things that configure configures. What might invalidate that configuration and make you need/want to rerun it?
----- R 5.4 -----
- Things that configure script configures:
  - Target hardware platform (PLATFORM line 20)
  - Target machine type (MACHINE line 21)
  - Optimization and debug flag (DEBUG line 24)
  - OS root directory (OSTREE line 30) we ran this during setup and install
- We would re-run this script when we need to:
  - Build and port to a different hardware and machine
  - Want to set different debug or optimization flag
  - Set the root directory to a different location (maybe not in os161 directory)


----- Q 5.5 ----- What are some of the details which would make a function "machine dependent"? Why might it be important to maintain this separation, instead of just putting all of the code in one function?
----- R 5.5 -----
- Files inside src/kern/arch often complain about compiler. We are ultimately running on the sys161 simulator, so functions need to accommodate for register differences
- Hardware interrupt, for example, will need to be machine dependent since different hardware might have different number of registers, CPU, bus, or memories such that we need to place exception handlers or bus driver at different addresses
- It is important to maintain separation so that we could keep code maintainable and keep abstraction, such as changing kernel without introducing bugs or issues into other programs. This would create an abstraction layer so machine-dependent code and machine-independent code are connected only by interfaces. We could simply write a new hardware interrupt function for the new hardware and keep the same interface, so programs do not have to worry about adapting to the new hardware.


----- Q 5.6 ----- How large is a trapframe? Why?
----- R 5.6 -----
- Mentioned in exception-mips1.S (line 133) we need to allocate stack space for 37 words to hold the trap frame
- In trapframe.h (src/kern/arch/mips/include/trapframe.h) there are 37 registers the trapframe needs to store, with each size of unsigned 32 bit integer
- So 37 * 32 => 1184 bits (148 bytes) in total


----- Q 5.7 ----- Under what circumstances should you re-run the kern/conf/config script?
----- R 5.7 -----
- If we ever want to change the kernel configuration (DUMBVM/DUMBVM-OPT/GENERIC/GENERIC-OPT)
- If we ever edited the configuration file for device drivers or changing options
- If a new source file is modified/add/removed to the kernel


----- Q 5.8 ----- Under what circumstances should you run bmake depend in kern/compile/DUMBVM?
----- R 5.8 -----
- For building the kernel the first time
- For building the kernel when any include files are changed/added/removed


----- Q 5.9 ----- Under what circumstances should you run bmake or bmake install in kern/compile/DUMBVM?
----- R 5.9 -----
- For building and installing the kernel if any kernel code is changed/added/removed
- Usually running these should be fine since we are not constantly changing dependencies


----- Q 5.10 ----- When you booted your kernel, you found that there were several commands that you could issue to experiment with it. Explain exactly where and what you would have to do to add a command that printed out, "Hello world!"
----- R 5.10 -----
- These commands are located in src/kern/main/menu.c
- Starting from line 527, commands are listed in the variable "cmdtable"
- To add a new command "helloworld", we need to create a function first:

static int cmd_helloworld(int n, char **a) {
  (void)n;
  (void)a;

  kprint("Hello world!\n");

  return 0;
}

- Then we can add this to cmdtable variable:

{"helloworld", cmd_helloworld}

- To let use know that this command exist, we can added to "opsmenu" variable on line 434

"[helloworld]   Print \"Hello world!\""

- Run "bmake" and "bmake install" in src/kern/compile/DUMBVM
- Run "sys161 kernel" in root/ to use the command


----- Q 5.11 ----- userland/bin/ -- all the utilities that are typically found in /bin, e.g., cat, cp, ls, etc. The things in bin are considered "fundamental" utilities that the system needs to run.
Why do we need to include these in your OS/161 distribution? Why can't you just use the standard utilities that are present on the machine on which you're working?
----- R 5.11 -----
- We are running os161 inside our simulator sys161
- Since our OS runs using MIPS instructions instead of the more common x86 instructions, the programs might not work for os161


----- Q 5.12 ----- When a user program exits, what is done with the program's return value?
----- R 5.12 -----
- Located in userland/lib/crt0/mips/crt0.S
  - Startup code that gets called before main()
  - And when main() returns
- Return value of main() is saved to register v0
- It is moved to s0 (callee-save) in case exit syscall returns 
- It is also saved to a0 as the argument for exit syscall - as the exit status code 


----- Q 5.13 ----- Imagine that you wanted to add a new system call. List all the places that you would need to modify/add code. Then review your answers to questions 7-9 and note which of those actions you need to take in order to test the new system call.
----- R 5.13 -----
- First need a system call number added to kern/include/kern/syscall.h
  - This constant is used in kern/arch/mips/syscall/syscall.c
- Create a function prototypes in kern/include/syscall.h
- Write the actual function implementation somewhere
  - Preferably saved in kern/syscall/ directory as suggested
- In syscall function in kern/arch/mips/syscall/syscall.c add a new switch-case for the new system call constant
  - Call the previous created function here

- Run ./config DUMBVM in src/kern/conf when new source file is added to the kernel
- Run "bmake depend", "bmake", "bmake" install in src/kern/compile/DUMBVM (or whatever configuration) 
- Run the kernel from root/